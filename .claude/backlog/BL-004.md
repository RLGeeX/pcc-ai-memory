# BL-004: Implement GitHub App Authentication for ArgoCD

## Metadata
- **Status**: Backlog
- **Priority**: High
- **Estimated Effort**: 15-20 minutes
- **Dependencies**:
  - ArgoCD deployed and operational (✅ Complete - Phase 6.10)
  - GitHub organization admin access required
  - PAT-based Git access currently functional (Phase 6.19)
- **Related Phases**: Phase 6.19 (Configure Git Credentials)
- **Created**: 2025-11-20
- **Category**: Security, GitOps, Authentication

## Problem Statement

### Current State
ArgoCD is configured to access Git repositories using a Personal Access Token (PAT) stored in Secret Manager. While functional, this approach has limitations:

**PAT Limitations**:
- **Expiration**: GitHub PATs expire after 90 days and require manual rotation
- **Scope**: PAT permissions are user-scoped (applies to all repos the user can access)
- **Audit Trail**: Actions appear as the PAT owner, not as ArgoCD system actions
- **Rotation Overhead**: Manual process to generate new PAT, update Secret Manager, restart ArgoCD components

### Expected Behavior
ArgoCD should use GitHub App authentication for accessing Git repositories, providing:
- **No Expiration**: GitHub Apps don't expire (credentials are long-lived)
- **Granular Permissions**: Repository-level access control (only repos explicitly granted)
- **Better Audit Trail**: Actions clearly identified as "ArgoCD GitOps Bot" in GitHub UI
- **Automatic Credential Refresh**: GitHub App generates short-lived installation tokens (1 hour) automatically refreshed by ArgoCD

### Business Impact
- Reduces operational overhead (no quarterly PAT rotation)
- Improves security posture (least privilege, granular access)
- Better compliance and auditing (clear attribution of automated actions)
- Production-ready authentication pattern (recommended by ArgoCD team)

## Technical Background

### GitHub App vs PAT vs SSH Deploy Key

| Feature | GitHub App | PAT | SSH Deploy Key |
|---------|-----------|-----|----------------|
| Expiration | Never (app-level) | 90 days | Never |
| Token Lifespan | 1 hour (auto-refresh) | Until expiration | N/A |
| Multi-Repo Access | Yes (per-installation) | Yes (user scope) | No (one key per repo) |
| Granular Permissions | Yes (repo-level) | No (user-level) | Yes (repo-level) |
| Audit Trail | App name visible | User name visible | Deployment key name |
| Rotation Overhead | None (auto-refresh) | Manual quarterly | None |
| Write Access | Configurable | Depends on user | Read-only by default |
| Recommended For | Production GitOps | Testing/development | Single-repo read-only |

### How GitHub App Works with ArgoCD

1. **GitHub App**: Installed at organization or repository level
2. **Private Key**: App's private key stored in ArgoCD as K8s secret
3. **Installation Token**: ArgoCD generates short-lived tokens (1 hour) using private key
4. **Auto-Refresh**: ArgoCD automatically requests new tokens before expiration
5. **Git Operations**: ArgoCD uses installation tokens for all Git operations (clone, fetch, pull)

## Prerequisites

- GitHub organization admin access (to create and install GitHub App)
- ArgoCD operational at https://argocd.nonprod.pcconnect.ai
- Repository: `pcc-argocd-config-nonprod` (created in Phase 6.19)
- Future repositories: `pcc-user-api`, `pcc-task-tracker-api`, etc. (contain Helm charts)

## Implementation Steps

### Step 1: Create GitHub App

**Navigate to GitHub Organization Settings**:
1. Go to https://github.com/organizations/PORTCoCONNECT/settings/apps
2. Click **New GitHub App**

**App Configuration**:

**GitHub App name**: `argocd-gitops-bot-nonprod`
- **Description**: `ArgoCD GitOps automation for nonprod testing cluster (pcc-gke-devops-nonprod)`
- **Homepage URL**: `https://argocd.nonprod.pcconnect.ai`
- **Webhook**: Uncheck "Active" (ArgoCD doesn't need webhooks for basic Git access)

**Repository permissions** (grant minimum required):
- **Contents**: Read-only (for cloning repos and reading manifests)
- **Metadata**: Read-only (automatically granted, can't change)

**Where can this GitHub App be installed?**
- Select: **Only on this account** (PORTCoCONNECT organization)

Click **Create GitHub App**

### Step 2: Generate Private Key

After creating the app:
1. Scroll to **Private keys** section
2. Click **Generate a private key**
3. Download the `.pem` file (e.g., `argocd-gitops-bot-nonprod.2025-11-20.private-key.pem`)
4. Store securely (will upload to Secret Manager in next step)

**Note the following values** (needed later):
- **App ID**: Shown at top of page (e.g., `123456`)
- **Installation ID**: Will get this after installing the app

### Step 3: Install GitHub App to Repositories

**Install the app**:
1. Click **Install App** in left sidebar
2. Select **PORTCoCONNECT** organization
3. Choose repository access:
   - **Select repositories** (recommended for least privilege)
   - Add: `pcc-argocd-config-nonprod`
   - (Later: add `pcc-user-api`, `pcc-task-tracker-api`, etc. as needed)
4. Click **Install**

**Get Installation ID**:
After installation, you'll be redirected to a URL like:
```
https://github.com/organizations/PORTCoCONNECT/settings/installations/12345678
```
The number at the end (`12345678`) is your **Installation ID**. Save this value.

Alternatively, get it via API:
```bash
# Using a temporary PAT or existing credentials
curl -H "Authorization: Bearer YOUR_PAT" \
  https://api.github.com/orgs/PORTCoCONNECT/installations

# Look for the installation matching your app
```

### Step 4: Store GitHub App Credentials in Secret Manager

**Upload Private Key**:
```bash
# Set variables
PROJECT_ID="pcc-prj-devops-nonprod"
PRIVATE_KEY_FILE="$HOME/Downloads/argocd-gitops-bot-nonprod.2025-11-20.private-key.pem"

# Create secret for GitHub App private key
gcloud secrets create argocd-github-app-private-key \
  --project=${PROJECT_ID} \
  --replication-policy="user-managed" \
  --locations="us-east4" \
  --data-file="${PRIVATE_KEY_FILE}"

# Grant ArgoCD service account access
gcloud secrets add-iam-policy-binding argocd-github-app-private-key \
  --project=${PROJECT_ID} \
  --member="serviceAccount:argocd-server@${PROJECT_ID}.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"

gcloud secrets add-iam-policy-binding argocd-github-app-private-key \
  --project=${PROJECT_ID} \
  --member="serviceAccount:argocd-repo-server@${PROJECT_ID}.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"

# Securely delete local private key file
shred -vfz -n 10 "${PRIVATE_KEY_FILE}"
```

**Store App ID and Installation ID**:
```bash
# Replace with your actual values
APP_ID="123456"
INSTALLATION_ID="12345678"

# Store App ID
echo -n "${APP_ID}" | gcloud secrets create argocd-github-app-id \
  --project=${PROJECT_ID} \
  --replication-policy="user-managed" \
  --locations="us-east4" \
  --data-file=-

# Grant access
gcloud secrets add-iam-policy-binding argocd-github-app-id \
  --project=${PROJECT_ID} \
  --member="serviceAccount:argocd-server@${PROJECT_ID}.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"

gcloud secrets add-iam-policy-binding argocd-github-app-id \
  --project=${PROJECT_ID} \
  --member="serviceAccount:argocd-repo-server@${PROJECT_ID}.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"

# Store Installation ID
echo -n "${INSTALLATION_ID}" | gcloud secrets create argocd-github-app-installation-id \
  --project=${PROJECT_ID} \
  --replication-policy="user-managed" \
  --locations="us-east4" \
  --data-file=-

# Grant access
gcloud secrets add-iam-policy-binding argocd-github-app-installation-id \
  --project=${PROJECT_ID} \
  --member="serviceAccount:argocd-server@${PROJECT_ID}.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"

gcloud secrets add-iam-policy-binding argocd-github-app-installation-id \
  --project=${PROJECT_ID} \
  --member="serviceAccount:argocd-repo-server@${PROJECT_ID}.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"
```

### Step 5: Configure ArgoCD to Use GitHub App

**Add GitHub App Credentials to ArgoCD**:

ArgoCD supports GitHub App authentication via repository credentials. The configuration uses the App ID, Installation ID, and Private Key.

```bash
# Get credentials from Secret Manager
APP_ID=$(gcloud secrets versions access latest \
  --secret=argocd-github-app-id \
  --project=${PROJECT_ID})

INSTALLATION_ID=$(gcloud secrets versions access latest \
  --secret=argocd-github-app-installation-id \
  --project=${PROJECT_ID})

PRIVATE_KEY=$(gcloud secrets versions access latest \
  --secret=argocd-github-app-private-key \
  --project=${PROJECT_ID})

# Add GitHub App credentials to ArgoCD via kubectl
kubectl create secret generic argocd-github-app-creds \
  -n argocd \
  --from-literal=githubAppID="${APP_ID}" \
  --from-literal=githubAppInstallationID="${INSTALLATION_ID}" \
  --from-literal=githubAppPrivateKey="${PRIVATE_KEY}" \
  --dry-run=client -o yaml | kubectl apply -f -

# Add repository credential template
# This tells ArgoCD to use GitHub App for all repos matching pattern
kubectl apply -f - <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: github-app-repo-creds
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repo-creds
stringData:
  type: git
  url: https://github.com/PORTCoCONNECT
  githubAppID: "${APP_ID}"
  githubAppInstallationID: "${INSTALLATION_ID}"
  githubAppPrivateKey: |
$(echo "${PRIVATE_KEY}" | sed 's/^/    /')
EOF
```

**Alternative: Update Existing Repository Configuration**:

If you already have repositories registered (from PAT method), update them to use GitHub App:

```bash
# Update repository to use GitHub App
argocd repo add https://github.com/PORTCoCONNECT/pcc-argocd-config-nonprod.git \
  --github-app-id "${APP_ID}" \
  --github-app-installation-id "${INSTALLATION_ID}" \
  --github-app-private-key-path <(echo "${PRIVATE_KEY}") \
  --insecure-skip-server-verification \
  --upsert
```

### Step 6: Validate GitHub App Access

**Test repository connection**:
```bash
# Via ArgoCD CLI
argocd repo list

# Expected output showing GitHub App authentication
# NAME                                                      TYPE  STATUS      PROJECT
# https://github.com/PORTCoCONNECT/pcc-argocd-config-nonprod git   Successful  default
```

**Check ArgoCD repo-server logs**:
```bash
kubectl logs -n argocd deployment/argocd-repo-server --tail=50 | grep -i github
```

Expected log entries:
```
time="..." level=info msg="Generating GitHub App token" app-id=123456 installation-id=12345678
time="..." level=info msg="Successfully authenticated with GitHub App"
```

**Test Git operations**:
```bash
# Trigger a repository refresh
argocd app get argocd-nonprod-root --refresh

# Should see successful sync without errors
```

### Step 7: Remove PAT Credentials (After Validation)

Once GitHub App is working, remove old PAT credentials:

```bash
# Delete PAT secret from Secret Manager
gcloud secrets delete argocd-github-pat \
  --project=${PROJECT_ID} \
  --quiet

# Remove PAT from ArgoCD repo credentials (if stored separately)
# This depends on how Phase 6.19 was implemented
```

### Step 8: Add Additional Repositories (Future)

When adding microservice repositories containing Helm charts:

**Option A: Via Repository Credential Template** (Automatic):
The repo-creds created in Step 5 automatically applies to all repos under `https://github.com/PORTCoCONNECT/*`

Just install the GitHub App to the new repository in GitHub UI.

**Option B: Explicit Repository Registration**:
```bash
argocd repo add https://github.com/PORTCoCONNECT/pcc-user-api.git \
  --github-app-id "${APP_ID}" \
  --github-app-installation-id "${INSTALLATION_ID}" \
  --github-app-private-key-path <(gcloud secrets versions access latest --secret=argocd-github-app-private-key)
```

## Validation Checklist

After implementation, verify:

- [ ] GitHub App created in PORTCoCONNECT organization
- [ ] Private key generated and downloaded
- [ ] App installed to `pcc-argocd-config-nonprod` repository
- [ ] App ID, Installation ID, and Private Key stored in Secret Manager
- [ ] ArgoCD service accounts granted secretAccessor role
- [ ] Repository credentials configured in ArgoCD
- [ ] ArgoCD can connect to repository (argocd repo list shows "Successful")
- [ ] Applications sync successfully (argocd app sync works)
- [ ] Repo-server logs show GitHub App authentication
- [ ] Old PAT credentials removed (after validation)

## Security Considerations

### GitHub App Private Key Protection
- **Storage**: Encrypted at rest in Secret Manager (AES-256)
- **Access**: Only ArgoCD service accounts via Workload Identity
- **Rotation**: Generate new private key annually (manual process):
  1. Generate new key in GitHub App settings
  2. Update Secret Manager with new key
  3. Restart ArgoCD repo-server: `kubectl rollout restart -n argocd deployment/argocd-repo-server`
  4. Delete old key from GitHub App settings

### Least Privilege
- GitHub App only has **Contents: Read** permission
- App only installed to specific repositories (not all repos in org)
- Installation ID limits access to approved repos only

### Audit Trail
GitHub activity shows:
- Actor: `argocd-gitops-bot-nonprod[bot]`
- Action: Clone, fetch operations
- Timestamp and IP address

View in GitHub organization audit log:
```
Settings → Audit log → Filter by: "app:argocd-gitops-bot-nonprod"
```

## Rollback Plan

If issues occur with GitHub App:

### Quick Rollback to PAT
```bash
# Re-create PAT in GitHub (if deleted)
# Store in Secret Manager
gcloud secrets create argocd-github-pat \
  --project=${PROJECT_ID} \
  --replication-policy="user-managed" \
  --locations="us-east4" \
  --data-file=<(echo -n "ghp_YOUR_NEW_PAT")

# Update ArgoCD repository credentials to use PAT
argocd repo add https://github.com/PORTCoCONNECT/pcc-argocd-config-nonprod.git \
  --username git \
  --password "$(gcloud secrets versions access latest --secret=argocd-github-pat)" \
  --upsert

# Verify connection
argocd repo list
```

### Troubleshooting GitHub App Issues

**Problem**: ArgoCD can't authenticate with GitHub App

**Check**:
1. Verify App ID and Installation ID are correct:
   ```bash
   gcloud secrets versions access latest --secret=argocd-github-app-id
   gcloud secrets versions access latest --secret=argocd-github-app-installation-id
   ```

2. Check private key format (should be PEM format with BEGIN/END markers):
   ```bash
   gcloud secrets versions access latest --secret=argocd-github-app-private-key | head -n 1
   # Expected: -----BEGIN RSA PRIVATE KEY-----
   ```

3. Verify GitHub App installation is active:
   - Go to https://github.com/organizations/PORTCoCONNECT/settings/installations
   - Should show "argocd-gitops-bot-nonprod" with green checkmark

4. Check ArgoCD repo-server logs for specific error:
   ```bash
   kubectl logs -n argocd deployment/argocd-repo-server --tail=100 | grep -i error
   ```

## Cost Impact

**GitHub App**: Free (included in GitHub organization)
**Secret Manager**: ~$0.06/month per secret × 3 secrets = ~$0.18/month
**Delta from PAT**: No change (PAT also used Secret Manager)

## References

### ArgoCD Documentation
- [Private Repositories - GitHub App](https://argo-cd.readthedocs.io/en/stable/user-guide/private-repositories/#github-app-credential)
- [Repository Credentials](https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#repository-credentials)

### GitHub Documentation
- [Creating a GitHub App](https://docs.github.com/en/apps/creating-github-apps/creating-github-apps/creating-a-github-app)
- [Installing GitHub Apps](https://docs.github.com/en/apps/using-github-apps/installing-your-own-github-app)
- [Authenticating as a GitHub App](https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/authenticating-as-a-github-app)

### Security Best Practices
- [GitHub App Security Best Practices](https://docs.github.com/en/apps/maintaining-github-apps/security-best-practices-for-github-apps)
- [GCP Secret Manager Security](https://cloud.google.com/secret-manager/docs/best-practices)

## Success Criteria

Implementation is considered complete when:

1. ✅ GitHub App created and installed to organization
2. ✅ Private key securely stored in Secret Manager
3. ✅ ArgoCD configured to use GitHub App credentials
4. ✅ Repository connections show "Successful" status
5. ✅ Applications sync without authentication errors
6. ✅ Audit logs show bot name (not user PAT)
7. ✅ Old PAT credentials removed
8. ✅ Repo-server logs show GitHub App token generation
9. ✅ No manual token rotation required for 90+ days

## Estimated Timeline

| Task | Duration | Notes |
|------|----------|-------|
| Create GitHub App | 5 min | Via GitHub organization settings |
| Generate and download private key | 2 min | One-click download |
| Install app to repositories | 3 min | Select repos and confirm |
| Store credentials in Secret Manager | 5 min | 3 secrets (key, app ID, installation ID) |
| Configure ArgoCD repository credentials | 3 min | kubectl apply or argocd CLI |
| Test and validate | 5 min | Verify connection and sync |
| Remove old PAT credentials | 2 min | Delete from Secret Manager |
| **Total** | **25 minutes** | Includes buffer for GitHub UI navigation |

Actual time may be 15-20 minutes for experienced administrators.

## Notes

- GitHub App tokens are short-lived (1 hour) but automatically refreshed by ArgoCD
- Installation tokens have same permissions as the GitHub App installation (read-only in this case)
- GitHub App approach is recommended by ArgoCD team for production use
- Private key rotation should be scheduled annually (manual process, low overhead)
- Repository credential templates (`repo-creds`) apply pattern-matching (e.g., `https://github.com/PORTCoCONNECT/*`) to automatically authenticate all matching repos
- No webhook configuration needed for basic Git operations (ArgoCD polls repositories)
- For faster sync, can configure webhooks later (optional enhancement)

## Future Enhancements

1. **Webhook Integration**: Configure GitHub App to send webhooks to ArgoCD for instant sync (instead of 3-minute polling)
2. **Write Access**: If needed for automated GitOps workflows (e.g., Renovate, image updater), grant **Contents: Write** permission
3. **Multiple Apps**: Create separate GitHub Apps for prod vs nonprod clusters for isolation
4. **Automated Key Rotation**: Implement automated private key rotation using Cloud Scheduler + Cloud Functions (advanced)

# BL-001: WireGuard Multi-Instance with Cloudflare DNS Load Balancing

**Status**: Backlog
**Priority**: Medium
**Estimated Effort**: 4-6 hours
**Dependencies**: None
**Related**: Phase VPN (wireguard-vpn.tf)

## Overview

Migrate WireGuard VPN infrastructure from single static IP to multi-instance architecture with ephemeral IPs and Cloudflare DNS-based load balancing. This enables horizontal scaling (1→4 instances) with automatic health checking and DNS updates.

## Current State (Single Static IP)

**Architecture**:
- Single WireGuard instance with static external IP
- MIG size = 1
- Manual scaling (requires Terraform changes + client reconfig)
- No automatic failover

**Resources**:
- `/home/jfogarty/pcc/infra/pcc-devops-infra/terraform/environments/nonprod/wireguard-vpn.tf`
- Static IP module: `module.wireguard_ip`
- Instance template: `module.wireguard_instance_template`

## Target State (Multi-Instance with Cloudflare)

**Architecture**:
```
Cloudflare DNS:
  wg-nonprod-us-east4.pcconnect.ai
    ↓ (health-checked A records)
    ├─ 35.x.x.1:51820 (instance 1, healthy)
    ├─ 35.x.x.2:51820 (instance 2, healthy)
    ├─ 35.x.x.3:51820 (instance 3, DOWN - excluded)
    └─ 35.x.x.4:51820 (instance 4, healthy)

  wg-prod-us-east4.pcconnect.ai
    ↓ (2-4 instances in us-east4)
    └─ Similar architecture

  wg-prod-us-central1.pcconnect.ai
    ↓ (2-4 instances in us-central1)
    └─ Similar architecture
```

**Key Changes**:
- Each instance gets ephemeral external IP (GCP auto-assigns)
- Startup script registers IP with Cloudflare API
- Cloudflare health checks all IPs (UDP 51820 or ICMP)
- Dead instances automatically removed from DNS responses
- Scaling: Change `target_size`, instances auto-register

## Implementation Details

### 1. Prerequisites

**Cloudflare Setup**:
- Cloudflare account with DNS zone for `pcconnect.ai`
- API token with permissions:
  - `Zone.DNS` (Edit)
  - Scoped to `pcconnect.ai` zone
- Zone ID for `pcconnect.ai`

**GCP Secret Manager**:
```bash
# Store Cloudflare credentials
gcloud secrets create cloudflare-api-token \
  --replication-policy="automatic" \
  --project=pcc-prj-devops-nonprod

gcloud secrets versions add cloudflare-api-token \
  --data-file=<(echo "YOUR_CF_API_TOKEN")

gcloud secrets create cloudflare-zone-id \
  --replication-policy="automatic" \
  --project=pcc-prj-devops-nonprod

gcloud secrets versions add cloudflare-zone-id \
  --data-file=<(echo "YOUR_CF_ZONE_ID")

# Grant service account access
gcloud secrets add-iam-policy-binding cloudflare-api-token \
  --member="serviceAccount:wireguard-vpn-sa@pcc-prj-devops-nonprod.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"

gcloud secrets add-iam-policy-binding cloudflare-zone-id \
  --member="serviceAccount:wireguard-vpn-sa@pcc-prj-devops-nonprod.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"
```

### 2. Update Instance Template

**File**: `/home/jfogarty/pcc/infra/pcc-devops-infra/terraform/environments/nonprod/wireguard-vpn.tf`

**Change**:
```hcl
module "wireguard_instance_template" {
  source = "git::ssh://git@github-pcc/PORTCoCONNECT/pcc-tf-library.git//modules/instance-template?ref=v0.1.0"

  # ... existing config ...

  # CHANGE: Enable ephemeral external IP (not static)
  enable_external_ip = true
  # REMOVE: nat_ip parameter (was: module.wireguard_ip.address)
  # KEEP: network_tier = "STANDARD" (or remove, uses default PREMIUM)

  tags = ["wireguard-vpn"]

  labels = {
    purpose     = "wireguard-vpn"
    environment = "nonprod"
  }

  metadata_startup_script = file("${path.module}/startup-script.sh")
}
```

### 3. Update Startup Script

**File**: `/home/jfogarty/pcc/infra/pcc-devops-infra/terraform/environments/nonprod/startup-script.sh`

**Add to startup script** (after WireGuard configuration, before service start):

```bash
###############################################################################
# Cloudflare DNS Registration
###############################################################################

log "Registering instance with Cloudflare DNS..."

# Get instance metadata
INSTANCE_NAME=$(curl -s -H "Metadata-Flavor: Google" \
  http://metadata.google.internal/computeMetadata/v1/instance/name)

INSTANCE_ID=$(curl -s -H "Metadata-Flavor: Google" \
  http://metadata.google.internal/computeMetadata/v1/instance/id)

ZONE=$(curl -s -H "Metadata-Flavor: Google" \
  http://metadata.google.internal/computeMetadata/v1/instance/zone | cut -d'/' -f4)

REGION=$(echo $ZONE | sed 's/-[a-z]$//')

EXTERNAL_IP=$(curl -s -H "Metadata-Flavor: Google" \
  http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/access-configs/0/external-ip)

# Get Cloudflare credentials from Secret Manager
CF_API_TOKEN=$(gcloud secrets versions access latest --secret="cloudflare-api-token" --project="${PROJECT_ID}")
CF_ZONE_ID=$(gcloud secrets versions access latest --secret="cloudflare-zone-id" --project="${PROJECT_ID}")

# Determine DNS name based on project and region
# Examples:
#   pcc-prj-devops-nonprod + us-east4 → wg-nonprod-us-east4.pcconnect.ai
#   pcc-prj-devops-prod + us-east4 → wg-prod-us-east4.pcconnect.ai
#   pcc-prj-devops-prod + us-central1 → wg-prod-us-central1.pcconnect.ai

if [[ "${PROJECT_ID}" == *"nonprod"* ]]; then
  ENV="nonprod"
elif [[ "${PROJECT_ID}" == *"prod"* ]]; then
  ENV="prod"
else
  ENV="unknown"
fi

# Convert region to DNS-friendly format (us-east4 stays as-is)
REGION_DNS=$(echo $REGION | tr '-' '-')

DNS_NAME="wg-${ENV}-${REGION_DNS}.pcconnect.ai"

log "DNS name: ${DNS_NAME}, External IP: ${EXTERNAL_IP}"

# Register with Cloudflare
REGISTER_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
  "https://api.cloudflare.com/client/v4/zones/${CF_ZONE_ID}/dns_records" \
  -H "Authorization: Bearer ${CF_API_TOKEN}" \
  -H "Content-Type: application/json" \
  --data '{
    "type": "A",
    "name": "'${DNS_NAME}'",
    "content": "'${EXTERNAL_IP}'",
    "ttl": 120,
    "proxied": false,
    "comment": "Auto-registered by '${INSTANCE_NAME}' (ID: '${INSTANCE_ID}') in '${ZONE}'"
  }')

HTTP_CODE=$(echo "$REGISTER_RESPONSE" | tail -n1)
RESPONSE_BODY=$(echo "$REGISTER_RESPONSE" | head -n-1)

if [[ "$HTTP_CODE" == "200" ]]; then
  log "Successfully registered ${EXTERNAL_IP} with Cloudflare DNS (${DNS_NAME})"
  RECORD_ID=$(echo "$RESPONSE_BODY" | jq -r '.result.id')
  log "Cloudflare DNS record ID: ${RECORD_ID}"

  # Store record ID for cleanup on shutdown (optional)
  echo "${RECORD_ID}" > /var/lib/wireguard/cloudflare-record-id
else
  log "ERROR: Failed to register with Cloudflare (HTTP ${HTTP_CODE})"
  log "Response: ${RESPONSE_BODY}"
  # Continue anyway - WireGuard can still work via direct IP
fi

log "Cloudflare DNS registration complete"
```

**Optional: Add cleanup on shutdown** (create systemd service):

```bash
# /etc/systemd/system/wireguard-cloudflare-cleanup.service
[Unit]
Description=Cleanup Cloudflare DNS record on shutdown
DefaultDependencies=no
Before=shutdown.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/cleanup-cloudflare-dns.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
```

```bash
#!/bin/bash
# /usr/local/bin/cleanup-cloudflare-dns.sh

RECORD_ID=$(cat /var/lib/wireguard/cloudflare-record-id 2>/dev/null)
if [[ -z "$RECORD_ID" ]]; then
  exit 0
fi

CF_API_TOKEN=$(gcloud secrets versions access latest --secret="cloudflare-api-token")
CF_ZONE_ID=$(gcloud secrets versions access latest --secret="cloudflare-zone-id")

curl -X DELETE \
  "https://api.cloudflare.com/client/v4/zones/${CF_ZONE_ID}/dns_records/${RECORD_ID}" \
  -H "Authorization: Bearer ${CF_API_TOKEN}"
```

### 4. Cloudflare DNS Configuration

**Via Cloudflare Dashboard**:

1. **Create DNS Records** (initially empty, instances will populate):
   - Name: `wg-nonprod-us-east4.pcconnect.ai`
   - Type: A record
   - TTL: 120 seconds (2 min for fast failover)
   - Proxy status: DNS only (not proxied)

2. **Configure Load Balancing** (optional, for health checks):
   - Pool: `wg-nonprod-us-east4-pool`
   - Health Check:
     - Type: ICMP Ping or UDP
     - Interval: 60 seconds
     - Timeout: 5 seconds
     - Retries: 2
   - Monitor: All registered IPs

3. **Repeat for other environments**:
   - `wg-prod-us-east4.pcconnect.ai`
   - `wg-prod-us-central1.pcconnect.ai`

**Via Terraform** (future enhancement):

```hcl
# cloudflare.tf (create in wireguard-vpn directory)
terraform {
  required_providers {
    cloudflare = {
      source  = "cloudflare/cloudflare"
      version = "~> 4.0"
    }
  }
}

provider "cloudflare" {
  api_token = var.cloudflare_api_token
}

resource "cloudflare_load_balancer_pool" "wireguard_nonprod_use4" {
  account_id = var.cloudflare_account_id
  name       = "wg-nonprod-us-east4-pool"

  # Origins will be dynamically added by startup script
  # This just creates the pool structure

  check_regions = ["WNAM", "ENAM"]

  monitor = cloudflare_load_balancer_monitor.wireguard_udp.id
}

resource "cloudflare_load_balancer_monitor" "wireguard_udp" {
  account_id = var.cloudflare_account_id
  type       = "udp_icmp"
  interval   = 60
  timeout    = 5
  retries    = 2
  port       = 51820
}
```

### 5. Update MIG Configuration

**File**: `/home/jfogarty/pcc/infra/pcc-devops-infra/terraform/environments/nonprod/wireguard-vpn.tf`

**Change**:
```hcl
module "wireguard_mig" {
  source = "git::ssh://git@github-pcc/PORTCoCONNECT/pcc-tf-library.git//modules/mig?ref=v0.1.0"

  project_id                = var.project_id
  name                      = "wireguard-vpn-mig"
  region                    = var.region
  instance_template         = module.wireguard_instance_template.self_link

  # CHANGE: Scale from 1 to 2-4 instances
  target_size               = 1  # Start with 1, scale to 4 when ready

  # CHANGE: Distribute across multiple zones for resilience
  distribution_policy_zones = ["us-east4-a", "us-east4-b", "us-east4-c"]

  update_policy = {
    type                  = "PROACTIVE"
    minimal_action        = "REPLACE"
    max_surge_fixed       = 1  # CHANGE: Allow 1 extra during updates
    max_unavailable_fixed = 1  # Keep at least N-1 instances healthy
    replacement_method    = "SUBSTITUTE"
  }

  auto_healing_policies = {
    health_check      = module.wireguard_health_check.self_link
    initial_delay_sec = 300
  }
}
```

### 6. Remove Static IP and Load Balancer

**Changes to wireguard-vpn.tf**:

```hcl
# REMOVE: Static IP module (no longer needed)
# module "wireguard_ip" {
#   source = "git::ssh://git@github-pcc/PORTCoCONNECT/pcc-tf-library.git//modules/static-ip?ref=v0.1.0"
#   ...
# }

# REMOVE: Load balancer module (no longer needed)
# module "wireguard_nlb" {
#   source = "git::ssh://git@github-pcc/PORTCoCONNECT/pcc-tf-library.git//modules/network-load-balancer?ref=v0.1.0"
#   ...
# }
```

### 7. WireGuard Client Configuration

**Update client configs** to use DNS name instead of IP:

```ini
[Interface]
PrivateKey = <client-private-key>
Address = 10.100.0.2/32
DNS = 10.100.0.1

[Peer]
PublicKey = <server-public-key>
# CHANGE: Use DNS name instead of static IP
Endpoint = wg-nonprod-us-east4.pcconnect.ai:51820
AllowedIPs = 10.24.0.0/14, 10.100.0.0/24
PersistentKeepalive = 25
```

**Benefits**:
- Clients automatically connect to healthy instances
- No client reconfiguration when scaling
- Fast failover (~2 min with PersistentKeepalive=25)

## DNS Names

| Environment | Region | DNS Name |
|------------|--------|----------|
| Nonprod | us-east4 | `wg-nonprod-us-east4.pcconnect.ai` |
| Prod | us-east4 | `wg-prod-us-east4.pcconnect.ai` |
| Prod | us-central1 | `wg-prod-us-central1.pcconnect.ai` |

## Scaling Procedure

**To scale from 1→4 instances**:

1. Update Terraform:
   ```hcl
   target_size = 4
   ```

2. Apply:
   ```bash
   terraform apply
   ```

3. Verify:
   ```bash
   # Check instances
   gcloud compute instances list --filter="labels.purpose=wireguard-vpn"

   # Check Cloudflare DNS
   curl -H "Authorization: Bearer $CF_API_TOKEN" \
     "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?name=wg-nonprod-us-east4.pcconnect.ai"
   ```

4. Done ✅

## Testing Plan

1. **Single Instance Test** (Phase 1):
   - Deploy with target_size=1
   - Verify instance registers with Cloudflare
   - Test client connection via DNS name
   - Verify DNS resolves to correct IP

2. **Scale-Out Test** (Phase 2):
   - Scale to target_size=2
   - Verify both instances register
   - Test DNS returns both IPs (round-robin)
   - Test failover: kill one instance, verify DNS updates

3. **Full Scale Test** (Phase 3):
   - Scale to target_size=4
   - Verify all 4 instances register
   - Test client connections distribute across instances
   - Test rolling update (MIG replaces instances one at a time)

## Rollback Plan

**If issues occur**:

1. Scale back to target_size=1
2. Revert to static IP configuration (keep old config in git)
3. Update client configs to use static IP
4. Investigate and fix issues
5. Retry when ready

## Cost Impact

**Current** (static IP):
- Static IP reservation: ~$3/month
- Single e2-small instance: ~$14/month
- **Total**: ~$17/month

**New** (ephemeral IPs, 4 instances):
- No static IP reservations: $0
- Four e2-small instances: ~$56/month
- Cloudflare DNS queries: Free (first 10M queries/month)
- **Total**: ~$56/month

**Delta**: +$39/month for 4x capacity and automatic failover

## Security Considerations

1. **Cloudflare API Token**:
   - Scoped to DNS-only permissions
   - Stored in GCP Secret Manager
   - Accessed via service account (least privilege)

2. **DNS Exposure**:
   - All instance IPs visible in public DNS
   - Firewall rules still protect UDP 51820 (WireGuard only)
   - WireGuard's cryptographic auth protects against unauthorized access

3. **Instance Metadata**:
   - Startup script logs may contain sensitive data
   - Ensure Cloud Logging filters secrets
   - Review stackdriver logs for leaks

## Success Criteria

✅ Single instance deploys and registers with Cloudflare
✅ DNS name resolves to instance IP
✅ Client connects via DNS name
✅ Scaling to 4 instances works without manual intervention
✅ All 4 instances visible in Cloudflare DNS
✅ Health checks detect and remove failed instances
✅ Client failover works within 2 minutes
✅ Rolling updates maintain at least 3/4 instances healthy

## Dependencies

- Cloudflare account with API access
- DNS zone `pcconnect.ai` managed in Cloudflare
- GCP Secret Manager for credentials
- Service account IAM permissions for Secret Manager

## Related Files

- `/home/jfogarty/pcc/infra/pcc-devops-infra/terraform/environments/nonprod/wireguard-vpn.tf`
- `/home/jfogarty/pcc/infra/pcc-devops-infra/terraform/environments/nonprod/startup-script.sh`
- `/home/jfogarty/pcc/core/pcc-tf-library/modules/instance-template/` (already supports enable_external_ip)

## Notes

- This approach works for WireGuard because clients re-resolve DNS and reconnect automatically
- Cloudflare's health checks ensure only healthy IPs are returned
- Ephemeral IPs are more cost-effective than reserved static IPs
- Instance replacement causes brief connection interruption (~2 min)
- Future enhancement: Automated DNS cleanup on instance shutdown (optional)

## References

- [Cloudflare DNS API Documentation](https://developers.cloudflare.com/api/operations/dns-records-for-a-zone-create-dns-record)
- [WireGuard Protocol Specification](https://www.wireguard.com/protocol/)
- [GCP MIG Rolling Updates](https://cloud.google.com/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups)
